<!DOCTYPE html>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<script src="../vendor/three.js/build/three.js"></script>
<script src="../vendor/three.js/examples/js/controls/OrbitControls.js"></script>
<script src="../vendor/jsartoolkit/artoolkit.debug.js"></script>
<script src="../vendor/jsartoolkit/artoolkit.api.js"></script>
<script src="three.artoolkitcontext.js"></script>
<script src="three.arsource.js"></script>
<script src="three.armarker.js"></script>
<script src="three.armultimarker.js"></script>
<style>
	body {
		margin : 0px;
		/*width: 100%;*/
	}
</style>
<div style='position:absolute; top: 10px; width: 100%; text-align: center; font-family: Monospace; font-weight: bold; padding;color:grey; z-index: 1000;'>
	Example of 
	<a href="https://github.com/artoolkit/jsartoolkit5" target="_blank">jsARToolKit</a> 
	by <a href="https://twitter.com/jerome_etienne" target="_blank">@jerome_etienne</a>
	with <a href="https://github.com/mrdoob/three.js" target="_blank">three.js</a>
	<br/>
	<a href="https://github.com/jeromeetienne/jsartoolkit-example" target="_blank">github repo</a>
	- Toggle :
	<a href='javascript:void(0)' onclick='toggleDebugDetect()' style='color: grey'>Debug Detection</a> /
	<a href='javascript:void(0)' onclick='toggleDebugCamera()' style='color: grey'>Debug Camera</a>
	<br/>
	Source:
	<a href='javascript:void(0)' onclick='switchSource("video")' style='color: grey'>video</a>
	<a href='javascript:void(0)' onclick='switchSource("image")' style='color: grey'>image</a>
	<a href='javascript:void(0)' onclick='switchSource("webcam")' style='color: grey'>webcam</a>
	<br/>
	(put this <a href='data/Hiro%20pattern%20with%20border.pdf' target='_blank'>hiro image</a> in front of the camera)
	- on android, click to start webcam
	<br/>
</div>
<body><script>
	var debugDetectEnabled	= optionPresentInHash('debugDetectEnabled') ? true : false
	var debugCameraEnabled	= optionPresentInHash('debugCameraEnabled') ? true : false

	//////////////////////////////////////////////////////////////////////////////
	//              Code Separator
	//////////////////////////////////////////////////////////////////////////////

	window.switchSource = function switchSource(sourceType){
		reloadOptions(sourceType, debugDetectEnabled, debugCameraEnabled)
	}
	window.toggleDebugDetect = function toggleDebugDetect(){
		reloadOptions(sourceType, debugDetectEnabled ? false : true, debugCameraEnabled)		
	}
	window.toggleDebugCamera = function toggleDebugCamera(){
		reloadOptions(sourceType, debugDetectEnabled, debugCameraEnabled ? false : true)		
	}
	


	function optionPresentInHash(varName) {
		var query = window.location.hash.substring(1);
		var vars = query.split('&');
		for (var i = 0; i < vars.length; i++) {
			if (decodeURIComponent(vars[i]) == varName) {
				return true
			}
		}
		return false
	}

	if( optionPresentInHash('webcam') === true ){
		var sourceType = 'webcam'
		var srcElement = THREE.ArSource.initWebcam(function(){
			onSourceImageReady(srcElement.videoWidth, srcElement.videoHeight)		
		})
		document.body.appendChild(srcElement)
	}else if( optionPresentInHash('image') === true ){
		var sourceType = 'image'
		var url = '../images/armchair.jpg'
		// var url = '../images/chalk.jpg'
		// var url = '../images/chalk_multi.jpg'
		// var url = '../images/kuva.jpg'
		// var url = '../images/img.jpg'
		var url = '../images/marker_cube_hamming63.png'
		var srcElement = THREE.ArSource.initImage(url, function(){
			onSourceImageReady(srcElement.width, srcElement.height)
		})
		document.body.appendChild(srcElement)
	}else if( optionPresentInHash('video') === true ){		
		var sourceType = 'video'
		// var url = '../videos/output_4.mp4';
		var url = '../videos/VID_20160503_165602.mp4'
		var url = '../videos/VID_20160503_165602-640x480.mp4'
		// var url = '../videos/headtracking.mp4'
		// var url = '../videos/me-marker-cube.mp4'
		var srcElement = THREE.ArSource.initVideo(url, function(){
			onSourceImageReady(srcElement.width, srcElement.height)
		})
		srcElement.playbackRate = 0.1
		srcElement.volume = 0
		// srcElement.autoplay = true
		// srcElement.controls =true
		document.body.appendChild(srcElement)
	}else {
		switchSource('video')
	}
	
        function reloadOptions(sourceType, debugDetectEnabled, debugCameraEnabled){
                var optionsString = ''
                optionsString += sourceType

                if( debugDetectEnabled === true ){
                        optionsString += (optionsString.length ? '&': '') + 'debugDetectEnabled'
                }

                if( debugCameraEnabled === true ){
                        optionsString += (optionsString.length ? '&': '') + 'debugCameraEnabled'
                }
		console.log(optionsString)
                location.hash   = '#'+optionsString
                location.reload()                
        }

	
	//////////////////////////////////////////////////////////////////////////////////
	//		Init
	//////////////////////////////////////////////////////////////////////////////////

	// init renderer
	var renderer	= new THREE.WebGLRenderer({
		antialias: true,
		alpha: true
	});
	renderer.setClearColor(new THREE.Color('lightgrey'), 0)
	// renderer.setSize( 1280/2, 960/2 );
	renderer.setSize( 640, 480 );
	renderer.domElement.style.position = 'absolute'
	renderer.domElement.style.top = '0px'
	renderer.domElement.style.left = '0px'
	document.body.appendChild( renderer.domElement );

document.body.appendChild(srcElement)
srcElement.play()

	// array of functions for the rendering loop
	var onRenderFcts= [];

	// init scene and camera
	var scene	= new THREE.Scene();

	var ambient = new THREE.AmbientLight( 0x666666 );
	scene.add( ambient );

	var directionalLight = new THREE.DirectionalLight( 0x887766 );
	directionalLight.position.set( -1, 1, 1 ).normalize();
	scene.add( directionalLight );
	
	//////////////////////////////////////////////////////////////////////////////////
	//		Comments
	//////////////////////////////////////////////////////////////////////////////////

	// Create a camera and a marker root object for your Three.js scene.
	var camera = new THREE.Camera();
	camera.updateProjectionMatrix = function(){} // required by THREE.CameraHelper
	camera.matrixAutoUpdate = false;
	scene.add(camera);
	
	if( debugCameraEnabled ){
		var cameraHelper = new THREE.CameraHelper(camera)
		scene.add(cameraHelper)

		// Create a three.js camera.
		var cameraDebug = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
		scene.add(cameraDebug);
		cameraDebug.position.x = -2
		cameraDebug.position.z = -10
		cameraDebug.lookAt(scene.position)

		var controls = new THREE.OrbitControls(cameraDebug)		
	}

	var arContext = null
	function onSourceImageReady(width, height, onCompleted){
		console.log(arguments)
		arContext = new THREE.ArtoolkitContext(width, height, camera, debugDetectEnabled, function(){
			console.log('arContext ready')
			
			// load kanji pattern
			// TODO pass that into promise
			// arContext.controller.loadMarker('../data/patt.kanji', function(markerId) {
			// 	var markerWidth = 1
			// 	var markerTracker = arContext.controller.trackPatternMarkerId(markerId, markerWidth);
			// 
			// 	// load hiro pattern
			// 	arContext.controller.loadMarker('../data/patt.hiro', function(markerId) {
			// 		var markerWidth = 1
			// 		var markerId = arContext.controller.trackPatternMarkerId(markerId, markerWidth);
			// 		console.log('hiro markerId', markerId)
			// 	});
			// });

			// good for roomspace
			// For more information about AR_MATRIX_CODE_3x3_HAMMING63
			// https://github.com/artoolkit/artoolkit5/tree/master/doc/patterns/Matrix%20code%203x3%20with%20Hamming%20(6%2C3)%20code
		        arContext.controller.setPatternDetectionMode(artoolkit.AR_MATRIX_CODE_DETECTION);
		        arContext.controller.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_3x3_HAMMING63);
		        // arContext.controller.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_3x3_PARITY65)
		})
	}

	onRenderFcts.push(function(){
		if( arContext === null ) return
		if( arContext.ready !== true )	return
		
		arContext.update(srcElement)
				
		// update markerRoot with the found markers
		arMarkers.forEach(function(arMarker){
			arMarker.update(arContext)
		})
		
		if( window.multiMarker ) multiMarker.update()
	})

	//////////////////////////////////////////////////////////////////////////////////
	//		configure ar markers
	//////////////////////////////////////////////////////////////////////////////////
	
	var arMarkers = []
	
	// var markerUnknown = buildDebugArMarker(-1, 'torusknot')
	// arMarkers.push( markerUnknown );
	// markerUnknown.originObject.position.y = 1
	
	var markerLeft = buildDebugArMarker(1)
	arMarkers.push( markerLeft )
	markerLeft.originObject.position.x =  3.8
	markerLeft.originObject.position.y = -0.1
	
	var markerMiddle = buildDebugArMarker(2)
	arMarkers.push( markerMiddle )

	var markerRight = buildDebugArMarker(0)
	arMarkers.push( markerRight )
	markerRight.originObject.position.x = -3.3
	markerRight.originObject.position.y = -0.2
	
	var multiMarker = new THREE.ArMultiMarker()
	multiMarker.arMarkers = arMarkers
	multiMarker.originObject.rotateX(-Math.PI/2)
	multiMarker.originObject.position.y = 5 
	var geometry	= new THREE.PlaneGeometry(40,40);
	var material	= new THREE.MeshBasicMaterial({
		map :  new THREE.TextureLoader().load( '../textures/UV_Grid_Sm.jpg', function onLoaded(texture){
			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;
			texture.repeat.set(4, 4);
		}),
		side : THREE.DoubleSide,
		opacity: 0.5,
		transparent: true,
	}); 
	var torus	= new THREE.Mesh( geometry, material );
	multiMarker.originObject.add( torus );
	scene.add(multiMarker.markerObject)
	
	function buildDebugArMarker(markerInfoId){		
		// create the marker Root
		var arMarker = new THREE.ArMarker();
		arMarker.markerInfoId = markerInfoId
		scene.add(arMarker.markerObject);

		// build the canvas for the texture
		var canvas = document.createElement('canvas')
		canvas.width = canvas.height = 256
		var context = canvas.getContext('2d')
		context.fillStyle = "rgb(0, 0, 200)";
		context.fillRect (0, 0, canvas.width, canvas.height);
		context.translate(canvas.width/2 * 3/5, canvas.height/2 * 5/3);
		context.fillStyle = "rgb(200, 0, 200)";
		context.font = "256px monospace";
		context.fillText(markerInfoId, 0, 1)

		// add a plane on the marker
		var geometry	= new THREE.CubeGeometry(1,1,1);
		var geometry	= new THREE.PlaneGeometry(1,1);
		var material	= new THREE.MeshBasicMaterial({
			map: new THREE.CanvasTexture( canvas ),
			transparent : true,
			opacity: 0.5,
			side: THREE.DoubleSide
		}); 
		var cube	= new THREE.Mesh( geometry, material );
		if( geometry instanceof THREE.CubeGeometry ){
			cube.position.z	= geometry.parameters.height/2
		}
		arMarker.markerObject.add( cube );

		// // add a torus knot	
		// var geometry	= new THREE.CubeGeometry(1,1,1);
		// var material	= new THREE.MeshNormalMaterial({
		// 	transparent : true,
		// 	opacity: 0.5,
		// 	side: THREE.DoubleSide
		// }); 
		// var mesh	= new THREE.Mesh( geometry, material );
		// arMarker.originObject.add( mesh );
	
		// return arMarker
		return arMarker
	}


//////////////////////////////////////////////////////////////////////////////
//	plane always in front of the camera, exactly as big as the viewpoer
//////////////////////////////////////////////////////////////////////////////

;(function(){
	if( debugCameraEnabled === false )	return

	var video = srcElement

	// build the plane
	var geometry = new THREE.PlaneGeometry(2, 2);
	// var geometry = new THREE.BoxGeometry(10,10);
	var material = new THREE.MeshBasicMaterial({
		// map : new THREE.TextureLoader().load('images/UV_Grid_Sm.jpg'),
		side: THREE.DoubleSide,
		opacity: 0.5,
		transparent: true,
	});
	var seethruPlane = new THREE.Mesh(geometry, material);
	scene.add(seethruPlane);

	material.map = new THREE.VideoTexture( video );
	material.map.minFilter = THREE.NearestFilter;
	material.map.maxFilter = THREE.NearestFilter;
	material.map.format = THREE.RGBFormat;
	material.map.generateMipmaps = false;

	onRenderFcts.push(function(delta){
		// camera.updateMatrixWorld(true)
	// var camera = cameraDebug
		// get seethruPlane position
		var position = new THREE.Vector3(0,0,30)
		camera.localToWorld(position)
		seethruPlane.position.copy(position)

		// get seethruPlane quaternion
		camera.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );	
		seethruPlane.quaternion.copy( camera.quaternion)

	// FIXME hardcoding fov/aspect get it from projection matrix
	camera.fov = 45
	camera.aspect = 640/480
		// get seethruPlane height relative to fov
		seethruPlane.scale.y = Math.tan(Math.PI/180 * camera.fov/2)*position.length()
		// get seethruPlane aspect
		seethruPlane.scale.x = seethruPlane.scale.y * camera.aspect
		
		// to mirror the video in x
		// seethruPlane.scale.x *= -1
	})

	window.addEventListener('resize', function(){
		updateSeeThruAspectUv(seethruPlane)	
	})
	video.addEventListener('canplaythrough', function(){
		updateSeeThruAspectUv(seethruPlane)
	})

	function updateSeeThruAspectUv(plane){
		if( video.videoWidth === 0 )	return
		if( video.videoHeight === 0 )	return

		var faceVertexUvs = plane.geometry.faceVertexUvs[0]
		var screenAspect = window.innerWidth / window.innerHeight
		var videoAspect = video.videoWidth / video.videoHeight
		// aspect hardcoded for jsartoolkit
		var videoAspect = 640 / 480
		
		plane.geometry.uvsNeedUpdate = true

		if( screenAspect >= videoAspect ){
			var actualHeight = videoAspect / screenAspect;
			// faceVertexUvs y 0
			faceVertexUvs[0][1].y = 0.5 - actualHeight/2
			faceVertexUvs[1][0].y = 0.5 - actualHeight/2
			faceVertexUvs[1][1].y = 0.5 - actualHeight/2

			// faceVertexUvs y 1
			faceVertexUvs[0][0].y = 0.5 + actualHeight/2
			faceVertexUvs[0][2].y = 0.5 + actualHeight/2
			faceVertexUvs[1][2].y = 0.5 + actualHeight/2
		}else{
			var actualWidth = screenAspect / videoAspect;

			// faceVertexUvs x 0
			faceVertexUvs[0][0].x = 0.5 - actualWidth/2
			faceVertexUvs[0][1].x = 0.5 - actualWidth/2
			faceVertexUvs[1][0].x = 0.5 - actualWidth/2
			
			// faceVertexUvs x 1
			faceVertexUvs[0][2].x = 0.5 + actualWidth/2
			faceVertexUvs[1][1].x = 0.5 + actualWidth/2
			faceVertexUvs[1][2].x = 0.5 + actualWidth/2
		}
	}
})()

	//////////////////////////////////////////////////////////////////////////////////
	//		render the whole thing on the page
	//////////////////////////////////////////////////////////////////////////////////

	// render the scene
	onRenderFcts.push(function(){

		if( debugCameraEnabled ){
			cameraHelper.update()
			renderer.render( scene, cameraDebug );
			return
		}		

		renderer.render( scene, camera )
	})

	// run the rendering loop
	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		onRenderFcts.forEach(function(onRenderFct){
			onRenderFct(deltaMsec/1000, nowMsec/1000)
		})
	})
</script></body>
